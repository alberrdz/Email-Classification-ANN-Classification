# Email-Classification-ANN-Classification

# RESUMEN
El presente documento describe la metodología utilizada para resolver un problema de reconocimiento de spam en correos electrónicos.
El spam es un problema informático que probablemente todos nosotros hemos sufrido. El spam es información no solicitada que se envía (comúnmente a través de correo electrónico) a una gran cantidad de usuarios simultáneamente de manera automática. El spam es a veces llamado también correo basura. Estos correos automatizados originalmente eran utilizados con fines de mercadotecnia, enviando información a usuarios potenciales sobre sus servicios. Sin embargo, esta técnica ha sido ampliada por hackers para enviar malware o código malicioso.
Tomando este problema, y con ayuda de un dataset con una considerable cantidad de ejemplos de correos spam y no spam, se entrenó una Red Neuronal Artificial para Clasificación con el fin de reconocer correos spam tomando en cuenta las palabras utilizadas en los correos. Se hizo uso del lenguaje de programación python, junto con scikit-learn para modelar y entrenar esta RNA y un archivo .csv como contenedor de los datos a analizar. En las próximas secciones se describirá en mayor detalle el proceso realizado.

# CARACTERÍSTICAS DEL PROBLEMA A ESTUDIAR Y LOS DATOS
El problema estudiado en esta investigación es un problema que, aunque en los últimos años ha disminuido, ha estado presente desde hace al menos dos décadas, y presenta un real problema, no sólo por la cantidad de información no solicitada que se recibe, sino por la gran cantidad de personas con gran habilidad sobre temas de informática con malas intenciones, así como wannabe hackers que pueden poner en riesgo la información en nuestro equipo. Es por esto que este problema no puede dejarse de lado, y, aunque los mayores proveedores de correo electrónico de la web tienen este problema controlado (o algo así), vale la pena poner en práctica, como ejercicio académico, la clasificación de estos correos. 
Para este caso de estudio, se utilizó un dataset formado por 5172 correos aleatoriamente extraídos. Cada una de estas muestras de correo va acompañada en el dataset por una serie de 3000 columnas, cada una con palabras que comúnmente se utilizan en el correo spam, y una columna que representa una salida de clasificación binaria donde 1 = spam, 0 = libre de spam.
Con esta información a la mano, y tomando en cuenta estas 3000 variables, se logró entrenar una RNA de clasificación capaz de predecir una clasificación satisfactoria, distinguiendo de esta forma los correos spam y los correos libre de spam.
Es importante mencionar que los correos muestra para este caso de estudio son enteramente redactados en inglés.

# METODOLOGÍA
Inicialmente, se buscó un dataset confiable y sencillamente documentado que nos permitiera estudiar el problema con facilidad y entrenar a la Red Neuronal con el menor grado de error posible. Se utilizó un dataset de 5172 x 3001 campos. Siendo 5172 las filas, representando 5172 ejemplos de correo electrónico, y sus 3001 respectivas columnas, donde las primeras 3000, son palabras más utilizadas en el correo de spam, con una entrada numérica natural que representa el número de veces que aparece esta palabra en el correo. Y siendo la última columna (la 3001) la salida, la cual es una clasificación binaria de 1 (spam) y 0 (libre de spam). 
Considerando este dataset, se desarrolló un código en python, con ayuda de las ciertas sublibrerías de scikit-learn, como lo son MLPClassifier (para construir y entrenar a la Red Neuronal Artificial de Clasifiación), accuracy_score (para proveer un modo de medir el grado de error de la clasificación de prueba contra la clasificación real marcada en el dataset), train_test_split (para hacer la partición del dataset y usar una parte para entrenamiento y otra para prueba) y librerías comunes de python como lo son numpy (para el uso de los archivos .csv contenedores de los datasets) y pickle para el guardado y cargado de los modelos generados por la RNA.
Con estas herramientas, se leyó el archivo con los datos de los correos electrónicos a clasificar, se particionó aleatoriamente el conjunto de los datos a un 70% de entrenamiento y 30% de prueba, se entrenó a la Red Neuronal Artificial con este 70% de los datos, utilizando como solver el método LBFGS. Se diseñó la una Red Neuronal Artificial de 3 capas, donde la capa oculta cuenta con 5 neuronas. Para hacer la selección del tamaño de esta capa se realizaron pruebas con menos neuronas, iniciando desde 2 hasta 5, y, al ver que el valor de error de las pruebas llegó a 0 se detuvieron las pruebas y se decidió este tamaño. Se predijo el resultado para el otro 30% del dataset y se obtuvo un error de aproximadamente 3%, lo cual es un muy buen resultado para el apenas entrenamiento. Finalmente, se guardó el modelo en un archivo .sav con ayuda de la librería pickle. 
A continuación, para la etapa de prueba y predicción, se creó un subset del dataset original, tomando 100 ejemplos aleatorios para poner a prueba a la RNA a resolverlos por medio del modelo anteriormente generado y guardado. Se realizó la predicción y se obtuvo un increíble resulado con error de 0%.
A continuación se describirá a detalle el código utilizado.
De la línea 1 a la 5, se importan las librerías necesarias, en este caso son sklearn, numpy y pickle. Posteriormente, de la línea 7 a la 10 se realiza la lectura del archivo .csv con los datos para entrenamiento, y se da retroalimentación al usuario por pantalla. En la línea 13 se realiza la partición del dataset en 70% entrenamiento y 30% prueba. En las líneas 16, 17 y 18 se realiza el entrenamiento del modelo y se da retroalimentación al usuario por pantalla. Se decidió aumentar el máximo número de iteraciones a 1500 ya que el default de scikit-learn es 1000 y en este caso se rebasaba; y por motivos de objetivos de desempeño se decidió realizarse con todas las iteraciones necesarias. En la línea 21 se hace la predicción del 30% restante del dataset, y en la 24 se calcula el error basado en el método accuracy_score de sickit-learn Metrics, imprimiéndolo en pantalla. Para concluir el entrenamiento del modelo, se guarda en un archivo .sav. Posteriormente, de la línea 32 a la 34 se lee el subset destinado a la prueba y predicción y se retroalimenta al usuario por pantalla. En la línea 37 se carga el modelo anteriormente generado y en la 40 se predicen clasificaciones basadas en las entradas contenidas en el subset de prueba. A modo de comparación, se imprimen las clasificaciones predichas por la RNA en la línea 43 y las clasificaciones reales guardadas en el subset en la línea 44. Por último, en las líneas 48 y 49 se calcula el error basado en accuracy_score para esta prueba. 
Los resultados se muestran en la siguiente sección.
